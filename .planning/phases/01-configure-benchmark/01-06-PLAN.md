---
phase: 01-configure-benchmark
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/wizard/step-upload.tsx
  - src/components/wizard/image-card.tsx
  - src/components/wizard/image-uploader.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Step 2 renders exactly N upload cards matching sampleCount from Step 1 (not a free-form dropzone)"
    - "Each empty card has its own embedded drag-and-drop upload zone"
    - "After uploading, image collapses to a thumbnail with the JSON editor visible and a Save button"
    - "Clicking Save validates JSON and collapses the card to a compact saved row"
    - "Clicking a saved card's thumbnail expands to show the full-size image"
    - "User cannot upload more images than the sampleCount -- there are exactly N slots, no more"
  artifacts:
    - path: "src/components/wizard/step-upload.tsx"
      provides: "N pre-initialized slot-based upload layout driven by sampleCount"
      contains: "sampleCount"
    - path: "src/components/wizard/image-card.tsx"
      provides: "Three-state card lifecycle: empty, editing, saved"
      contains: "Save"
    - path: "src/components/wizard/image-uploader.tsx"
      provides: "Single-file embedded dropzone for individual card slots"
      contains: "onFileAccepted"
  key_links:
    - from: "src/components/wizard/step-upload.tsx"
      to: "sampleCount prop"
      via: "Array.from({ length: sampleCount }) to create N slots"
      pattern: "sampleCount"
    - from: "src/components/wizard/image-card.tsx"
      to: "step-upload.tsx"
      via: "onSave callback triggers state change from editing to saved"
      pattern: "onSave"
    - from: "src/components/wizard/image-uploader.tsx"
      to: "image-card.tsx"
      via: "Embedded single-file dropzone inside empty card state"
      pattern: "onFileAccepted"
---

<objective>
Restructure Step 2 upload UX from free-form dropzone to N structured card slots matching sampleCount.

Purpose: UAT test 7 failed because Step 2 uses a single shared dropzone allowing unlimited uploads instead of creating exactly N upload cards (one per sample from Step 1). Each card needs a three-state lifecycle: empty (upload zone), editing (thumbnail + JSON editor + Save), and saved (collapsed row). This is the user's core feedback on the wizard upload experience.

Output: Rewritten step-upload.tsx, image-card.tsx, and image-uploader.tsx implementing the slot-based card architecture with three-state lifecycle.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/step2-upload-cards.md
@.planning/phases/01-configure-benchmark/01-03-SUMMARY.md
@src/app/(app)/benchmark/new/page.tsx
@src/types/wizard.ts
@src/lib/config/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restructure StepUpload to slot-based layout and rewrite ImageUploader as single-file embedded dropzone</name>
  <files>src/components/wizard/step-upload.tsx, src/components/wizard/image-uploader.tsx</files>
  <action>
**step-upload.tsx -- full rewrite of the upload layout:**

1. Replace the current architecture (single ImageUploader dropzone + dynamically appended ImageCard list) with a slot-based architecture. Pre-initialize N slots using `Array.from({ length: sampleCount })` where each slot maps to a position index (0-based). Each slot gets a label like "Image 1", "Image 2", etc.

2. Maintain the existing `images: ImageEntry[]` array from props, but now each entry corresponds to a slot index. Use the index to match images to slots. An empty slot has no corresponding entry in the `images` array yet.

3. For each slot, render an ImageCard component. Pass it:
   - `slotIndex` (number) -- for the "Image N" label
   - `image` (ImageEntry | null) -- null for empty slots, the matching entry for filled slots
   - `uploading` (boolean) -- whether this slot is currently uploading
   - `draftId` (string) -- for the upload path
   - `onFileAccepted` (file: File) => void -- handles a single file upload for this slot
   - `onJsonChange`, `onValidChange`, `onRemove`, `onSave` callbacks

4. Move the upload logic (signed URL + Supabase Storage upload) INTO step-upload.tsx as a `handleFileForSlot(slotIndex: number, file: File)` function. This reuses the existing signed URL + uploadToSignedUrl pattern from the current handleFilesAccepted, but handles ONE file at a time for a specific slot. On success, create the ImageEntry and add/update it in the images array at that slot position. On failure, show error and remove the entry.

5. Keep the existing `imagesRef` pattern for async callback freshness.

6. Keep the validation summary section at the bottom but update the logic: progress shows `savedCount / sampleCount` where savedCount = images that have `jsonValid === true` AND have been "saved" (see Task 2 for the saved state). The `allValid` check should be `images.length === sampleCount && images.every(img => img.jsonValid)`. Note: the parent page.tsx `canContinue` logic (line 324-327) already checks `images.length >= configData.sampleCount && images.every(img => img.jsonValid)` -- this remains correct since the slot architecture ensures images.length never exceeds sampleCount.

7. Remove the separate ImageUploader component rendering at the top. Each card now embeds its own upload zone when in the "empty" state.

**image-uploader.tsx -- convert to single-file embedded dropzone:**

1. Rename the component to `SlotDropzone` (export as `SlotDropzone`).

2. Remove the `currentCount` prop and `MAX_IMAGES` logic entirely. This is now a single-file dropzone embedded in an empty card slot.

3. New props interface:
   ```
   interface SlotDropzoneProps {
     slotLabel: string;       // e.g. "Image 1"
     onFileAccepted: (file: File) => void;
     onError: (message: string) => void;
     disabled?: boolean;
   }
   ```

4. Configure react-dropzone with `multiple: false`, `maxFiles: 1`, same `accept` and `maxSize` from constants.

5. Render a compact upload zone with the Upload icon, the slot label ("Image 1"), and "Drag & drop or click to upload" text. Use similar styling to the current dropzone but more compact (p-6 instead of p-8) since it sits inside a card.

6. On drop, call `onFileAccepted(acceptedFiles[0])` for the single file.
  </action>
  <verify>
1. `npx tsc --noEmit` passes -- no type errors in the restructured components
2. `npm run build` passes
3. Grep confirms: step-upload.tsx contains `sampleCount` used to generate slots, NOT a single top-level `ImageUploader` call
4. Grep confirms: image-uploader.tsx exports `SlotDropzone` with `multiple: false`
5. Grep confirms: step-upload.tsx does NOT import MAX_IMAGES anywhere
  </verify>
  <done>StepUpload renders exactly N card slots based on sampleCount prop. Each empty slot contains an embedded SlotDropzone for single-file upload. The shared top-level dropzone is gone. Upload logic handles one file per slot.</done>
</task>

<task type="auto">
  <name>Task 2: Implement three-state ImageCard lifecycle (empty, editing, saved)</name>
  <files>src/components/wizard/image-card.tsx</files>
  <action>
**Rewrite ImageCard with three visual states:**

The card state is derived from props, not internal state:
- **empty**: `image` is null -- show the SlotDropzone inside the card
- **editing**: `image` is not null AND card is not saved -- show thumbnail + JSON editor + Save button
- **saved**: `image` is not null AND card has been saved -- show compact collapsed row

Add a `saved` boolean tracking state. This should be managed locally in each card: starts `false` when an image is first uploaded, becomes `true` when the user clicks Save (only if JSON is valid). Clicking the expand toggle on a saved card should allow re-editing (sets saved back to false). IMPORTANT: initialize `saved` to `true` if the image already has `jsonValid === true` on mount (handles draft restoration).

**Props interface (replace current):**
```typescript
interface ImageCardProps {
  slotIndex: number;
  image: ImageEntry | null;
  uploading?: boolean;
  onFileAccepted: (file: File) => void;
  onJsonChange: (value: string) => void;
  onValidChange: (isValid: boolean, parsed: unknown) => void;
  onRemove: () => void;
  onError: (message: string) => void;
}
```

**Empty state (image === null, not uploading):**
- Render a card with the slot label "Image {slotIndex + 1}" and an embedded `SlotDropzone` component
- Card has dashed border styling like the current upload zone
- Keep it visually lightweight

**Editing state (image !== null, saved === false):**
- Card header row: small thumbnail (48x48 rounded, object-cover), filename, file size, JSON status badge (reuse existing JsonStatusBadge), and a remove button (Trash2 icon)
- Clicking the thumbnail opens a full-size preview. Use a simple toggle: when thumbnail is clicked, show the full-size image above the JSON editor. Click again to hide. Do NOT use a modal -- just an inline expandable preview within the card.
- Below the header: the JsonEditor component (existing, no changes needed)
- Below the editor: a "Save" button (right-aligned). The Save button is DISABLED if `!image.jsonValid`. When clicked, set `saved = true`. Style: `Button variant="primary" size="sm"`.
- The card has a solid border, slightly highlighted (e.g., `border-ember/30`) to indicate it needs attention.

**Saved state (image !== null, saved === true):**
- Compact single row: small thumbnail (40x40), filename, file size, green "Valid" badge with checkmark, and an "Edit" button (pencil icon or text link)
- Clicking "Edit" sets `saved = false` to re-enter editing state
- Clicking the thumbnail shows full-size inline preview (same toggle as editing state)
- Card has a subtle green-tinted left border or green checkmark to indicate completion
- Remove button still available

**Important implementation details:**
- Import `SlotDropzone` from `./image-uploader` for the empty state
- Keep the existing `JsonStatusBadge` sub-component (move it above the main export if needed)
- Use `lucide-react` icons: Check, X, Trash2, Pencil (or Edit2), Minus, Loader2
- The `onFileAccepted` prop is passed through to SlotDropzone for the empty state
- Do NOT show the full-size image by default in editing state -- only show thumbnail. Full-size is behind a click on the thumbnail.
- When card transitions from empty to editing (image prop goes from null to non-null), the card should already be in editing mode (saved=false)
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` passes
3. Grep confirms: image-card.tsx contains "Save" button text
4. Grep confirms: image-card.tsx references `SlotDropzone`
5. Grep confirms: image-card.tsx has all three states distinguishable (check for "saved" state variable)
6. Run `npm run dev`, navigate to /benchmark/new, set sample count to 3 in Step 1, proceed to Step 2: verify 3 empty card slots appear with "Image 1", "Image 2", "Image 3" labels and embedded upload zones
  </verify>
  <done>ImageCard has three visual states: empty (embedded dropzone), editing (thumbnail + JSON editor + Save button), and saved (compact row with Edit button). Cards start as empty slots, transition to editing on upload, and collapse to saved on Save click. Thumbnail click toggles full-size inline preview in both editing and saved states. Draft restoration correctly initializes saved state for images with valid JSON.</done>
</task>

</tasks>

<verification>
- Step 2 renders exactly N cards matching sampleCount (test with 1, 3, 5)
- Empty cards show embedded upload zones with "Image N" labels
- Uploading a file transitions card from empty to editing state
- Editing state shows thumbnail (not full-size), JSON editor, and Save button
- Save button is disabled when JSON is invalid
- Clicking Save collapses card to compact saved row
- Clicking thumbnail in editing/saved state toggles inline full-size preview
- Clicking Edit on saved card re-enters editing state
- Progress bar shows savedCount / sampleCount
- Continue button enables when all N images have valid JSON
- `npm run build` passes with no errors
- Draft restoration correctly restores card states (saved images start in saved state)
</verification>

<success_criteria>
1. Step 2 shows exactly N upload card slots (N = sampleCount from Step 1)
2. User cannot upload more images than sampleCount (each slot accepts exactly one file)
3. Each card follows the lifecycle: empty -> editing (thumbnail + JSON + Save) -> saved (compact row)
4. Clicking Save validates JSON and collapses the card
5. Clicking thumbnail toggles full-size inline preview
6. All images with valid JSON = Continue button enabled
7. Build passes, no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-configure-benchmark/01-06-SUMMARY.md`
</output>
