---
phase: 02-pay-and-run
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/benchmark/json-compare.ts
  - src/lib/benchmark/json-compare.test.ts
  - src/lib/benchmark/backoff.ts
  - src/lib/benchmark/backoff.test.ts
  - src/lib/benchmark/cost-tracker.ts
  - src/lib/benchmark/cost-tracker.test.ts
  - src/lib/benchmark/runner.ts
  - vitest.config.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "JSON canonicalization produces deterministic output (sorted keys, normalized numbers, trimmed whitespace)"
    - "Strict comparison fails on any field mismatch including null vs missing key"
    - "Relaxed comparison treats string '1' as equal to number 1, collapses whitespace, treats null as missing"
    - "Field-level accuracy calculates correct fields / total fields as a percentage"
    - "Binary exact-match returns true only when entire canonical forms are identical"
    - "Adaptive backoff respects Retry-After header and uses exponential backoff with jitter on 429s"
    - "Cost tracker accumulates per-request costs and aborts when ceiling is reached"
    - "Cost tracker reserves estimated cost before API call and adjusts after response"
    - "Model runner calls OpenRouter chat completions API with image URL and extraction prompt"
  artifacts:
    - path: "src/lib/benchmark/json-compare.ts"
      provides: "JSON canonicalization, strict comparison, relaxed comparison, field-level accuracy scoring"
      exports: ["canonicalize", "compareStrict", "compareRelaxed", "calculateFieldAccuracy", "diffFields"]
    - path: "src/lib/benchmark/backoff.ts"
      provides: "Adaptive exponential backoff with jitter for rate-limited API calls"
      exports: ["withBackoff"]
    - path: "src/lib/benchmark/cost-tracker.ts"
      provides: "Real-time cost accumulation with reservation pattern and hard ceiling enforcement"
      exports: ["CostTracker"]
    - path: "src/lib/benchmark/runner.ts"
      provides: "Single model benchmark runner that calls OpenRouter and captures metrics"
      exports: ["runModelBenchmark"]
  key_links:
    - from: "src/lib/benchmark/runner.ts"
      to: "src/lib/benchmark/json-compare.ts"
      via: "Compare model output against expected JSON"
      pattern: "compareStrict|compareRelaxed|calculateFieldAccuracy"
    - from: "src/lib/benchmark/runner.ts"
      to: "src/lib/benchmark/cost-tracker.ts"
      via: "Reserve and record cost per API call"
      pattern: "costTracker\\.reserve|costTracker\\.record"
    - from: "src/lib/benchmark/runner.ts"
      to: "src/lib/benchmark/backoff.ts"
      via: "Wrap API call with retry on 429"
      pattern: "withBackoff"
---

<objective>
Build and test the benchmark engine utility modules: JSON canonicalization and comparison (strict + relaxed modes), adaptive backoff for rate limits, real-time cost tracking with ceiling enforcement, and single-model runner for OpenRouter API calls.

Purpose: These are the core building blocks for the benchmark orchestration engine. Each module has well-defined input/output contracts making them ideal TDD candidates. Testing these in isolation ensures the engine will produce accurate, reliable results.

Output: Four tested utility modules with comprehensive test suites validating all edge cases from the user decisions (coercion rules, null handling, whitespace normalization, cost reservation pattern, backoff behavior).
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pay-and-run/02-CONTEXT.md
@.planning/phases/02-pay-and-run/02-RESEARCH.md

Key existing files to reference:
@src/types/benchmark.ts
@src/lib/config/models.ts
@src/lib/config/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: JSON canonicalization and comparison with strict and relaxed matching modes (TDD)</name>
  <files>
    src/lib/benchmark/json-compare.ts
    src/lib/benchmark/json-compare.test.ts
    vitest.config.ts
    package.json
  </files>
  <action>
    **Setup vitest** if not already configured:
    - `npm install -D vitest` (check if already present first)
    - Create `vitest.config.ts` with path alias resolution matching tsconfig.json (`@/` -> `src/`)
    - Verify `npm test` runs vitest (add script to package.json if needed)

    **RED phase -- Write failing tests first (`src/lib/benchmark/json-compare.test.ts`):**

    Test suite for `canonicalize()`:
    - Sorts object keys recursively: `{ b: 1, a: 2 }` -> `{ a: 2, b: 1 }`
    - Sorts nested objects: `{ b: { d: 1, c: 2 }, a: 3 }` -> `{ a: 3, b: { c: 2, d: 1 } }`
    - Normalizes numbers: `"8.00"` stays as string `"8.00"` (canonicalize preserves types), but number `8.00` becomes `8`
    - Handles arrays (preserves order, recursively canonicalizes elements)
    - Handles null, boolean, empty objects, empty arrays
    - Trims whitespace from string values: `"  hello  "` -> `"hello"`
    - Produces identical output for semantically identical inputs with different key order

    Test suite for `compareStrict()`:
    - Returns true for identical canonical JSON
    - Returns false when a field value differs (number mismatch)
    - Returns false when null vs missing key (strict distinguishes these per user decision)
    - Returns false when types differ: string `"1"` vs number `1`
    - Returns false when whitespace differs in original but not after canonicalization
    - Returns true for `{ a: 1 }` vs `{ a: 1 }` after both canonicalized

    Test suite for `compareRelaxed()`:
    - Returns true for string `"1"` vs number `1` (loose coercion per user decision)
    - Returns true for number `1` vs number `1.0` (same value)
    - Returns true for `"8.00"` (string) vs `8` (number) (semantic equivalence)
    - Returns true for null value vs missing key (relaxed treats as equivalent per user decision)
    - Returns true for `"New  York"` vs `"New York"` (whitespace collapsed per user decision)
    - Returns false for `"New York"` vs `"new york"` (case preserved per user decision)
    - Returns true for `"  hello  "` vs `"hello"` (leading/trailing whitespace normalized)

    Test suite for `calculateFieldAccuracy()`:
    - Returns 100 for identical objects
    - Returns 50 when 1 of 2 fields match
    - Returns 0 when no fields match
    - Handles nested fields (flatten with dot notation paths)
    - Returns field-level diff with expected vs actual for each mismatch

    Test suite for `diffFields()`:
    - Returns empty array for identical objects
    - Returns array of `{ fieldPath, expected, actual }` for each mismatching field
    - Handles nested paths: `"items[0].price"` format
    - Handles extra fields in actual (not in expected)
    - Handles missing fields in actual (in expected but not actual)

    **GREEN phase -- Implement `src/lib/benchmark/json-compare.ts`:**

    `canonicalize(value: unknown): unknown` -- Recursively sort object keys, trim string values, normalize number formatting (strip trailing decimal zeros). Does NOT do type coercion (that's the relaxed comparator's job).

    `compareStrict(expected: unknown, actual: unknown): boolean` -- Canonicalize both inputs, then deep-equal compare. Null vs missing key is a mismatch.

    `compareRelaxed(expected: unknown, actual: unknown): boolean` -- Apply relaxed normalization before comparison:
    - Coerce numeric strings to numbers for comparison (`"1"` == `1`, `"8.00"` == `8`)
    - Collapse multiple whitespace to single space in strings
    - Trim leading/trailing whitespace
    - Treat null and missing key as equivalent (add missing key as null before compare)
    - Preserve case sensitivity (`"New York"` != `"new york"`)

    `calculateFieldAccuracy(expected: Record<string, unknown>, actual: Record<string, unknown>, mode: 'strict' | 'relaxed'): { accuracy: number; totalFields: number; correctFields: number }` -- Flatten both objects to dot-notation paths, compare each field using the specified mode, return percentage.

    `diffFields(expected: Record<string, unknown>, actual: Record<string, unknown>, mode: 'strict' | 'relaxed'): Array<{ fieldPath: string; expected: string; actual: string }>` -- Return list of field-level mismatches.

    **REFACTOR phase:** Clean up, ensure all tests pass, verify no unnecessary complexity.

    Run: `npm test -- src/lib/benchmark/json-compare.test.ts`
  </action>
  <verify>
    - All tests in json-compare.test.ts pass: `npm test -- src/lib/benchmark/json-compare.test.ts`
    - Strict mode correctly distinguishes null vs missing key
    - Relaxed mode correctly coerces "1" to match 1
    - Relaxed mode preserves case sensitivity
    - Field accuracy calculation handles nested objects
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    JSON comparison module handles both strict and relaxed matching modes with all user-specified coercion rules. Field-level accuracy and diff reporting works for nested JSON structures. All edge cases from user decisions are covered by tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Adaptive backoff, cost tracker, and model runner (TDD)</name>
  <files>
    src/lib/benchmark/backoff.ts
    src/lib/benchmark/backoff.test.ts
    src/lib/benchmark/cost-tracker.ts
    src/lib/benchmark/cost-tracker.test.ts
    src/lib/benchmark/runner.ts
  </files>
  <action>
    **Backoff module -- RED then GREEN:**

    Tests for `withBackoff()` (`src/lib/benchmark/backoff.test.ts`):
    - Calls the function once on success (no retry)
    - Retries on 429 status up to maxRetries
    - Respects Retry-After header (in seconds)
    - Uses exponential backoff with jitter when no Retry-After header
    - Throws after maxRetries exhausted
    - Does NOT retry on non-429 errors (e.g., 500, 400)
    - Backoff delay increases exponentially: base * 2^attempt (capped at 30s)
    - Jitter adds random 0-1s to prevent thundering herd

    Implementation (`src/lib/benchmark/backoff.ts`):
    ```typescript
    interface BackoffOptions {
      maxRetries?: number;    // default: 5
      baseDelayMs?: number;   // default: 1000
      maxDelayMs?: number;    // default: 30000
    }

    export async function withBackoff<T>(
      fn: () => Promise<T>,
      options?: BackoffOptions
    ): Promise<T>
    ```
    On 429 response (detect via error.status === 429 or response.status === 429):
    - Check for Retry-After header value
    - If present, wait that many seconds
    - If not, wait: min(baseDelay * 2^attempt + random(0, 1000), maxDelay)
    - Retry up to maxRetries times
    The function should accept a generic async function and handle the retry logic. The 429 detection should work with fetch Response objects -- the fn should throw an object with status and optionally headers.

    Use `vi.useFakeTimers()` in tests to avoid real delays. Mock the async function to simulate 429s.

    **Cost tracker module -- RED then GREEN:**

    Tests for `CostTracker` (`src/lib/benchmark/cost-tracker.test.ts`):
    - Initializes with zero spent and given ceiling
    - `reserve(amount)` reduces available budget and returns a reservation token
    - `record(token, actualCost)` adjusts the reservation to actual cost
    - `release(token)` releases an unused reservation
    - `canAfford(estimatedCost)` returns false when remaining budget < estimatedCost
    - `shouldAbort()` returns true when spent >= ceiling
    - Throws/returns false when reservation would exceed ceiling
    - Concurrent reservations are tracked independently
    - `getSpent()` returns total confirmed spend
    - `getRemaining()` returns ceiling minus (spent + reserved)
    - Uses internal buffer: ceiling is set to $6.50 (INTERNAL_COST_BUFFER from constants) to leave room for in-flight requests, but hard abort at HARD_COST_CEILING ($15)

    Implementation (`src/lib/benchmark/cost-tracker.ts`):
    ```typescript
    export class CostTracker {
      constructor(softCeiling?: number, hardCeiling?: number);
      reserve(estimatedCost: number): string;  // returns reservation ID
      record(reservationId: string, actualCost: number): void;
      release(reservationId: string): void;
      canAfford(estimatedCost: number): boolean;
      shouldAbort(): boolean;
      getSpent(): number;
      getReserved(): number;
      getRemaining(): number;
      getSummary(): { spent: number; reserved: number; remaining: number; ceiling: number };
    }
    ```

    **Model runner (`src/lib/benchmark/runner.ts`):**
    NOT TDD (depends on external API). Standard implementation.

    ```typescript
    export interface RunResult {
      outputJson: unknown;
      isValidJson: boolean;
      responseTimeMs: number;
      inputTokens: number;
      outputTokens: number;
      actualCost: number;
      error?: string;
    }

    export async function runModelBenchmark(params: {
      modelId: string;
      imageUrl: string;
      extractionPrompt: string;
      jsonSchema: Record<string, unknown>;
      costTracker: CostTracker;
    }): Promise<RunResult>
    ```

    Implementation:
    - Check `isMockOpenRouter()` from debug config. If mock mode:
      - Return realistic mock data with varied accuracy, latencies (200-5000ms), token counts, costs
      - Randomly simulate some failures (~10% error rate), some partial JSON, some rate limits
      - Use model ID to seed variation (different models produce different quality results)
      - Add realistic delay (500-2000ms) to simulate network latency

    - Real mode:
      - Reserve estimated cost via costTracker.reserve()
      - Start timing (performance.now())
      - Call OpenRouter API: POST `https://openrouter.ai/api/v1/chat/completions`
        - Headers: `Authorization: Bearer ${OPENROUTER_API_KEY}`, `Content-Type: application/json`, `HTTP-Referer: ${NEXT_PUBLIC_SITE_URL}`, `X-Title: ModelPick`
        - Body: model, messages with image_url content part and text prompt, response_format: { type: "json_object" }
        - Message structure: system message with extraction instructions, user message with image URL and prompt
      - Wrap the fetch call with `withBackoff()` for 429 handling
      - Stop timing
      - Parse response: extract choices[0].message.content, usage.prompt_tokens, usage.completion_tokens
      - Calculate actual cost from token counts and model pricing (lookup from CURATED_MODELS)
      - Record actual cost via costTracker.record()
      - Try to JSON.parse the output content. Set isValidJson accordingly.
      - Return RunResult

    Run all tests: `npm test`
  </action>
  <verify>
    - All tests pass: `npm test`
    - Backoff retries on 429, respects Retry-After, exponential delay
    - CostTracker reservation pattern works: reserve -> record adjusts, release frees
    - CostTracker correctly signals abort at ceiling
    - Runner exports runModelBenchmark function
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    Backoff handles 429 rate limits with exponential delay and jitter. Cost tracker uses reservation pattern to prevent ceiling overruns from concurrent calls. Model runner calls OpenRouter API with vision content, captures all metrics, and supports mock mode with realistic varied data. All utility modules are tested and type-safe.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes all test suites (json-compare, backoff, cost-tracker)
2. `npx tsc --noEmit` passes with zero errors
3. JSON strict mode: null != missing key, "1" != 1
4. JSON relaxed mode: null == missing key, "1" == 1, case preserved
5. Backoff: exponential delay increases, respects Retry-After, max 5 retries
6. CostTracker: reservation prevents double-counting, abort at ceiling
7. Runner: mock mode returns varied realistic data, real mode calls OpenRouter
</verification>

<success_criteria>
- All tests pass with `npm test`
- JSON comparison handles both matching modes per user decisions
- Field-level accuracy calculation works for nested JSON
- Backoff module handles 429s with exponential backoff and jitter
- Cost tracker enforces soft ceiling ($6.50 buffer) and hard ceiling ($15)
- Model runner supports both mock and real OpenRouter modes
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-pay-and-run/02-02-SUMMARY.md`
</output>
