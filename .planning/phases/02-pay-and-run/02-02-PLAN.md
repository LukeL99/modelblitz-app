---
phase: 02-pay-and-run
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/benchmark/json-compare.ts
  - src/lib/benchmark/backoff.ts
  - src/lib/benchmark/cost-tracker.ts
  - src/lib/benchmark/runner.ts
autonomous: true

must_haves:
  truths:
    - "JSON canonicalization sorts keys, normalizes numbers, trims strings for deterministic comparison"
    - "Binary exact-match comparison returns true only when canonicalized forms are identical"
    - "Relaxed comparison additionally lowercases strings, collapses whitespace, and parses number strings"
    - "Field-level diff identifies every path where expected and actual values diverge"
    - "Single model runner calls OpenRouter API with image URL and extraction prompt, capturing JSON output, response time, token counts, and cost"
    - "Adaptive backoff retries on 429 with exponential delay, jitter, and Retry-After header respect"
    - "Cost tracker accumulates per-call costs and reports remaining budget"
  artifacts:
    - path: "src/lib/benchmark/json-compare.ts"
      provides: "JSON canonicalization, exact-match comparison, relaxed comparison, field-level diff"
      exports: ["canonicalize", "canonicalizeRelaxed", "jsonMatch", "fieldDiff"]
    - path: "src/lib/benchmark/backoff.ts"
      provides: "Adaptive exponential backoff with jitter and Retry-After support"
      exports: ["withBackoff", "BackoffConfig"]
    - path: "src/lib/benchmark/cost-tracker.ts"
      provides: "Real-time cost accumulation with budget ceiling enforcement"
      exports: ["CostTracker"]
    - path: "src/lib/benchmark/runner.ts"
      provides: "Single model benchmark run against OpenRouter API"
      exports: ["runModelOnce", "RunResult"]
  key_links:
    - from: "src/lib/benchmark/runner.ts"
      to: "https://openrouter.ai/api/v1/chat/completions"
      via: "fetch with Authorization header"
      pattern: "fetch.*openrouter"
    - from: "src/lib/benchmark/runner.ts"
      to: "src/lib/benchmark/backoff.ts"
      via: "withBackoff wrapping fetch call"
      pattern: "withBackoff"
    - from: "src/lib/benchmark/runner.ts"
      to: "src/lib/config/models.ts"
      via: "ModelInfo type for model pricing data"
      pattern: "ModelInfo"
---

<objective>
Build the benchmark engine utility modules: JSON canonicalization and comparison for accuracy scoring, adaptive backoff for rate limit handling, cost tracking for budget enforcement, and single-model runner for OpenRouter API calls.

Purpose: These are the core building blocks the benchmark orchestration engine will compose. Each is independently testable pure logic or single-responsibility utility.
Output: Four self-contained modules in src/lib/benchmark/ that the engine orchestrator (Plan 02-03) will import.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research patterns for JSON comparison, backoff, cost tracking, runner
@.planning/phases/02-pay-and-run/02-RESEARCH.md

# Types and config needed by runner
@src/types/benchmark.ts
@src/lib/config/models.ts
@src/lib/config/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: JSON canonicalization, comparison, and field-level diff</name>
  <files>src/lib/benchmark/json-compare.ts</files>
  <action>
    Create `src/lib/benchmark/json-compare.ts` with four exported functions following research Pattern 4:

    **`canonicalize(value: unknown): unknown`**
    Recursively canonicalize a JSON value for deterministic comparison:
    - `null`/`undefined` -> `null`
    - `boolean` -> pass through
    - `number` -> `parseFloat(value.toString())` (strips trailing zeros like "8.00" -> 8)
    - `string` -> `value.trim()`
    - `Array` -> `value.map(canonicalize)` (preserve order, recurse elements)
    - `object` -> sort keys alphabetically, recurse into values
    Return the canonicalized value.

    **`canonicalizeRelaxed(value: unknown): unknown`**
    Same as canonicalize with additional normalization for "close enough" matching:
    - `string` -> try `Number(value)`: if parseable and non-empty, return as number. Otherwise lowercase, collapse whitespace (`/\s+/g` -> " "), trim.
    - All other types same as `canonicalize` but recurse with `canonicalizeRelaxed`.

    **`jsonMatch(expected: unknown, actual: unknown, relaxed?: boolean): boolean`**
    Compare two JSON values after canonicalization. Apply `canonicalize` (or `canonicalizeRelaxed` if `relaxed=true`), then `JSON.stringify` both and compare strings. Returns true if identical.

    **`fieldDiff(expected: Record<string, unknown>, actual: Record<string, unknown>, relaxed?: boolean, prefix?: string): Array<{ path: string; expected: unknown; actual: unknown }>`**
    Compute field-level diff between expected and actual JSON objects:
    - Union all keys from both objects
    - For keys missing in actual: add diff with `actual: undefined`
    - For keys missing in expected: add diff with `expected: undefined`
    - For matching keys where both values are plain objects (not arrays): recurse with dotted path prefix
    - For all other matching keys: canonicalize both values and compare. If different, add diff.
    Returns array of `{ path, expected, actual }` for all mismatched fields.

    Important: This module is pure logic with zero external dependencies. It does not import any libraries -- only TypeScript standard operations.
  </action>
  <verify>
    1. `npm run build` passes
    2. `grep "export function canonicalize" src/lib/benchmark/json-compare.ts` confirms export
    3. `grep "export function jsonMatch" src/lib/benchmark/json-compare.ts` confirms export
    4. `grep "export function fieldDiff" src/lib/benchmark/json-compare.ts` confirms export
    5. `grep "export function canonicalizeRelaxed" src/lib/benchmark/json-compare.ts` confirms export
  </verify>
  <done>
    Four pure functions: canonicalize (strict), canonicalizeRelaxed (lenient), jsonMatch (binary comparison), fieldDiff (field-by-field difference). No external dependencies. Ready for engine to use for accuracy scoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Adaptive backoff, cost tracker, and OpenRouter model runner</name>
  <files>
    src/lib/benchmark/backoff.ts
    src/lib/benchmark/cost-tracker.ts
    src/lib/benchmark/runner.ts
  </files>
  <action>
    **Create `src/lib/benchmark/backoff.ts`:**
    Follow research Pattern 5. Export `BackoffConfig` interface and `withBackoff` function.

    `BackoffConfig`: `maxRetries: number` (default 5), `baseDelayMs: number` (default 1000), `maxDelayMs: number` (default 60000).

    `withBackoff<T>(fn: () => Promise<Response>, config?: BackoffConfig): Promise<Response>`:
    - Call `fn()` to get a Response
    - If response status is NOT 429 OR retries exhausted, return the response
    - On 429: check `Retry-After` header. If present, parse as seconds and multiply by 1000 for delay. If absent, use exponential backoff: `baseDelay * 2^(attempt-1)` plus jitter `Math.random() * exponential * 0.5`, capped at `maxDelayMs`.
    - Log retry attempt: `console.log(\`[backoff] Rate limited (429). Retry ${attempt}/${config.maxRetries} after ${delayMs}ms\`)`
    - `await new Promise(r => setTimeout(r, delayMs))` then retry
    - Return final response (either success or last 429 after max retries)

    **Create `src/lib/benchmark/cost-tracker.ts`:**
    Follow research Pattern 6. Export `CostTracker` class.

    Constructor takes `ceiling: number`.
    Private `spent: number = 0`.
    Methods:
    - `addCost(cost: number): void` -- accumulates spend
    - `getSpent(): number` -- returns total spend so far
    - `getRemaining(): number` -- returns `Math.max(0, ceiling - spent)`
    - `canAfford(estimatedCost: number): boolean` -- returns `spent + estimatedCost <= ceiling`
    - `isExhausted(): boolean` -- returns `spent >= ceiling`

    Additionally, add a `estimateCost(model: ModelInfo, inputTokens: number, outputTokens: number): number` standalone exported function (not on the class) that calculates: `(inputTokens * model.inputCostPer1M / 1_000_000) + (outputTokens * model.outputCostPer1M / 1_000_000)`. This is the primary cost tracking mechanism per research Pitfall 4 -- we calculate cost from token counts and model pricing, not relying solely on OpenRouter's `usage.cost`.

    Import `ModelInfo` from `@/types/benchmark`.

    **Create `src/lib/benchmark/runner.ts`:**
    Follow research Pattern 3. Export `RunResult` interface and `runModelOnce` function.

    `RunResult` interface: `modelId: string`, `output: string`, `parsedOutput: unknown`, `responseTimeMs: number`, `promptTokens: number`, `completionTokens: number`, `totalTokens: number`, `cost: number` (calculated from token counts and model pricing, NOT from `usage.cost`), `success: boolean`, `error?: string`.

    `runModelOnce(model: ModelInfo, imageUrl: string, extractionPrompt: string): Promise<RunResult>`:
    1. Record `startTime = performance.now()`
    2. Wrap the fetch call with `withBackoff()` from `./backoff`
    3. The fetch call hits `OPENROUTER_BASE_URL` (from constants) with:
       - Headers: `Authorization: Bearer ${process.env.OPENROUTER_API_KEY}`, `Content-Type: application/json`, `HTTP-Referer: ${process.env.NEXT_PUBLIC_SITE_URL || "https://modelpick.ai"}`, `X-Title: ModelPick`
       - Body: `{ model: model.id, messages: [{ role: "user", content: [{ type: "text", text: extractionPrompt }, { type: "image_url", image_url: { url: imageUrl } }] }], response_format: { type: "json_object" }, temperature: 0, max_tokens: 4096 }`
    4. Record `responseTimeMs = performance.now() - startTime`
    5. If response not OK, return error result with `success: false` and HTTP error details
    6. Parse response JSON. Extract `content = data.choices?.[0]?.message?.content || ""`
    7. Extract `usage = data.usage || {}`
    8. Try `JSON.parse(content)` for `parsedOutput`. Set `success = true` if parse succeeds.
    9. **Calculate cost from model pricing** (primary mechanism per research Pitfall 4): `cost = estimateCost(model, usage.prompt_tokens || 0, usage.completion_tokens || 0)` using the `estimateCost` function from `./cost-tracker`. Fall back to `usage.cost` from OpenRouter if token counts are 0 but usage.cost exists.
    10. Return `RunResult` with all fields populated.

    Wrap entire function in try/catch for network errors -- return error result on catch.

    Import `ModelInfo` from `@/types/benchmark`, `OPENROUTER_BASE_URL` from `@/lib/config/constants`, `withBackoff` from `./backoff`, `estimateCost` from `./cost-tracker`.
  </action>
  <verify>
    1. `npm run build` passes
    2. `grep "export async function withBackoff" src/lib/benchmark/backoff.ts` confirms export
    3. `grep "export class CostTracker" src/lib/benchmark/cost-tracker.ts` confirms export
    4. `grep "export function estimateCost" src/lib/benchmark/cost-tracker.ts` confirms export
    5. `grep "export async function runModelOnce" src/lib/benchmark/runner.ts` confirms export
    6. `grep "export interface RunResult" src/lib/benchmark/runner.ts` confirms export
    7. `grep "withBackoff" src/lib/benchmark/runner.ts` confirms backoff integration
    8. `grep "estimateCost" src/lib/benchmark/runner.ts` confirms calculated cost (not relying on usage.cost)
  </verify>
  <done>
    Backoff utility retries 429s with exponential delay + jitter + Retry-After respect. CostTracker accumulates spend against a budget ceiling. estimateCost calculates per-call cost from model pricing (not relying on OpenRouter usage.cost). Runner calls OpenRouter API with image URL, captures timing, tokens, calculated cost, parsed JSON output. All four modules have no cross-plan file dependencies.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build` exits 0
2. All four modules in src/lib/benchmark/ exist and export correctly
3. json-compare.ts has no external imports (pure logic)
4. runner.ts uses withBackoff for rate limit resilience
5. runner.ts uses estimateCost for cost calculation (not relying solely on usage.cost)
6. cost-tracker.ts implements canAfford/isExhausted for budget enforcement
7. backoff.ts respects Retry-After header
</verification>

<success_criteria>
- JSON canonicalize handles objects (key sort), arrays (preserve order), numbers (normalize), strings (trim)
- JSON relaxed mode additionally lowercases, collapses whitespace, parses number strings
- fieldDiff returns array of path-level differences between two JSON objects
- Backoff retries up to 5 times on 429 with exponential delay + jitter
- CostTracker tracks spend and reports remaining budget
- Runner captures response time, token counts, calculated cost, parsed JSON, and error state
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-pay-and-run/02-02-SUMMARY.md`
</output>
