---
phase: 02-pay-and-run
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .env.local.example
  - src/lib/stripe/client.ts
  - src/lib/stripe/config.ts
  - src/lib/supabase/admin.ts
  - src/lib/config/constants.ts
  - src/types/database.ts
  - supabase/migrations/003_benchmark_runs.sql
  - src/app/api/checkout/route.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/app/(app)/benchmark/new/page.tsx
  - src/app/checkout/success/page.tsx
  - src/app/checkout/cancel/page.tsx
  - src/app/(app)/benchmark/[id]/processing/page.tsx
autonomous: true
user_setup:
  - service: stripe
    why: "Payment processing for $14.99 benchmark reports"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key"
      - name: STRIPE_WEBHOOK_SECRET
        source: "For local dev: run `stripe listen --forward-to localhost:3000/api/webhooks/stripe` and use the provided signing secret. For production: Stripe Dashboard -> Developers -> Webhooks -> Add endpoint -> Signing secret"
    dashboard_config:
      - task: "Create webhook endpoint pointing to /api/webhooks/stripe"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint"
      - task: "Select checkout.session.completed event"
        location: "Stripe Dashboard -> Developers -> Webhooks -> endpoint -> Events"
  - service: supabase
    why: "Service role key for webhook/engine operations that bypass RLS"
    env_vars:
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Settings -> API -> service_role key (secret)"

must_haves:
  truths:
    - "User clicks 'Pay & Run Benchmark' on completed wizard and is redirected to Stripe Checkout"
    - "After paying $14.99, Stripe webhook creates a report record and triggers benchmark execution"
    - "Webhook is idempotent -- duplicate Stripe deliveries do not create duplicate reports"
    - "User sees a processing page after payment showing report status"
    - "User can cancel checkout and return to the wizard"
  artifacts:
    - path: "src/lib/stripe/client.ts"
      provides: "Stripe server client singleton"
      exports: ["stripe"]
    - path: "src/lib/supabase/admin.ts"
      provides: "Service-role Supabase client for server operations without user session"
      exports: ["createAdminClient"]
    - path: "src/app/api/checkout/route.ts"
      provides: "POST endpoint to create Stripe Checkout session"
      exports: ["POST"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler with signature verification and idempotent processing"
      exports: ["POST", "maxDuration"]
    - path: "supabase/migrations/003_benchmark_runs.sql"
      provides: "benchmark_runs table, stripe_session_id on reports, RLS policies"
      contains: "CREATE TABLE benchmark_runs"
    - path: "src/app/(app)/benchmark/[id]/processing/page.tsx"
      provides: "Post-payment processing page with report status polling"
  key_links:
    - from: "src/app/(app)/benchmark/new/page.tsx"
      to: "/api/checkout"
      via: "fetch POST on checkout button click"
      pattern: "fetch.*api/checkout"
    - from: "src/app/api/checkout/route.ts"
      to: "stripe.checkout.sessions.create"
      via: "Stripe SDK"
      pattern: "stripe\\.checkout\\.sessions\\.create"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "supabase.from('reports').insert"
      via: "Admin Supabase client creating report from draft"
      pattern: "from.*reports.*insert"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "runBenchmark"
      via: "after() background execution"
      pattern: "after.*runBenchmark"
---

<objective>
Set up Stripe payment infrastructure and webhook-driven benchmark triggering. User can pay $14.99 via Stripe Checkout hosted redirect, and the webhook reliably creates a report record with idempotency before triggering background benchmark execution.

Purpose: This is the payment gateway for the product -- converting configured benchmarks into paid report executions. Without this, there is no revenue path.
Output: Stripe client, checkout API, webhook handler, DB migration, admin Supabase client, processing page, checkout UI integration.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 foundation (DB schema, types, models, constants)
@.planning/phases/01-configure-benchmark/01-01-SUMMARY.md
# Phase 1 wizard completion (draft status='ready', selected_models, schema_data)
@.planning/phases/01-configure-benchmark/01-04-SUMMARY.md

# Research patterns for Stripe, webhook, admin client
@.planning/phases/02-pay-and-run/02-RESEARCH.md

# Existing files to extend
@src/types/database.ts
@src/lib/config/constants.ts
@src/lib/supabase/server.ts
@supabase/migrations/001_initial_schema.sql
@src/app/(app)/benchmark/new/page.tsx
@.env.local.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, create Stripe client, admin Supabase client, DB migration, and extend types</name>
  <files>
    package.json
    src/lib/stripe/client.ts
    src/lib/stripe/config.ts
    src/lib/supabase/admin.ts
    src/lib/config/constants.ts
    src/types/database.ts
    supabase/migrations/003_benchmark_runs.sql
    .env.local.example
  </files>
  <action>
    **Install new dependencies:**
    ```bash
    npm install stripe resend @react-email/components p-limit
    ```

    **Create `src/lib/stripe/client.ts`:**
    Stripe server client singleton. Import `Stripe` from `stripe`, export `const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)` with `typescript: true` option. This is server-only (no NEXT_PUBLIC_ prefix on the secret key).

    **Create `src/lib/stripe/config.ts`:**
    Export constants: `STRIPE_PRICE_AMOUNT = 1499` (cents), `STRIPE_CURRENCY = "usd"`, `STRIPE_PRODUCT_NAME = "ModelPick Benchmark Report"`. These are used by the checkout route to create inline price_data (no pre-created Stripe Price object needed).

    **Create `src/lib/supabase/admin.ts`:**
    Service-role Supabase client that bypasses RLS. Use `createClient` from `@supabase/supabase-js` (NOT the SSR version). Takes `NEXT_PUBLIC_SUPABASE_URL` and `SUPABASE_SERVICE_ROLE_KEY` from env. Set `auth: { autoRefreshToken: false, persistSession: false }`. Export `createAdminClient()` function. This is used by webhook handlers and the benchmark engine where there is no user session.

    **Extend `src/lib/config/constants.ts`:**
    Add these constants:
    - `PER_MODEL_CONCURRENCY = 3` (max simultaneous calls to same model)
    - `GLOBAL_CONCURRENCY = 10` (max simultaneous API calls total)
    - `COST_SOFT_CEILING = 6.50` (internal soft ceiling to allow for in-flight calls, ~$0.50 buffer before the $7 hard ceiling)
    - `MAX_BENCHMARK_DURATION_S = 750` (graceful shutdown threshold, 50s before Vercel's 800s max)
    - `OPENROUTER_BASE_URL = "https://openrouter.ai/api/v1/chat/completions"`
    - `DEFAULT_INPUT_TOKENS = 1500` (estimated input tokens per vision call -- reuse existing value from cost estimator)
    - `DEFAULT_OUTPUT_TOKENS = 500` (estimated output tokens per vision call)

    **Extend `src/types/database.ts`:**
    Add `BenchmarkRun` interface with fields: `id: string`, `report_id: string`, `model_id: string`, `image_index: number`, `output_json: string | null`, `response_time_ms: number`, `prompt_tokens: number`, `completion_tokens: number`, `total_tokens: number`, `cost: number`, `passed: boolean`, `field_diffs: Array<{ path: string; expected: unknown; actual: unknown }>`, `error: string | null`, `created_at: string`.

    Add `benchmark_runs` to the `Database` interface Tables section with Row, Insert, and Update types following the same pattern as existing tables.

    Update `Report` interface to add `stripe_session_id: string | null` field.

    Update the Database.reports types to include `stripe_session_id` in Row and make it optional in Insert/Update.

    **Create `supabase/migrations/003_benchmark_runs.sql`:**
    Follow the exact migration from research (Pattern 8 in 02-RESEARCH.md):
    - `ALTER TABLE reports ADD COLUMN IF NOT EXISTS stripe_session_id TEXT UNIQUE;`
    - `CREATE TABLE benchmark_runs` with all columns (id UUID PK, report_id FK, model_id TEXT, image_index INT, output_json TEXT, response_time_ms INT, prompt_tokens INT, completion_tokens INT, total_tokens INT, cost NUMERIC(10,6), passed BOOLEAN, field_diffs JSONB, error TEXT, created_at TIMESTAMPTZ)
    - Indexes on report_id and (report_id, model_id)
    - Enable RLS
    - SELECT policies for authenticated users (via report ownership) and public (via share_token)
    - INSERT policy for service_role
    - UPDATE policy for service_role on reports table

    **Update `.env.local.example`:**
    Add new env vars with comments:
    ```
    # Stripe
    STRIPE_SECRET_KEY=sk_test_xxx
    STRIPE_WEBHOOK_SECRET=whsec_xxx

    # Supabase Service Role (server-only, never expose to client)
    SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

    # OpenRouter
    OPENROUTER_API_KEY=sk-or-xxx

    # Resend (email)
    RESEND_API_KEY=re_xxx
    ```
  </action>
  <verify>
    1. `npm run build` passes (no import errors, type errors)
    2. `ls src/lib/stripe/client.ts src/lib/stripe/config.ts src/lib/supabase/admin.ts` confirms files exist
    3. `grep "stripe_session_id" src/types/database.ts` finds the new field
    4. `grep "BenchmarkRun" src/types/database.ts` finds the new interface
    5. `grep "benchmark_runs" supabase/migrations/003_benchmark_runs.sql` finds the table
  </verify>
  <done>
    Stripe SDK installed. Server client created. Admin Supabase client created. DB migration defines benchmark_runs table with RLS. Types extended with BenchmarkRun and stripe_session_id. Constants extended with benchmark engine config. Env example updated with all new vars.
  </done>
</task>

<task type="auto">
  <name>Task 2: Checkout API, webhook handler, success/cancel pages, and processing page</name>
  <files>
    src/app/api/checkout/route.ts
    src/app/api/webhooks/stripe/route.ts
    src/app/checkout/success/page.tsx
    src/app/checkout/cancel/page.tsx
    src/app/(app)/benchmark/[id]/processing/page.tsx
    src/app/(app)/benchmark/new/page.tsx
  </files>
  <action>
    **Create `src/app/api/checkout/route.ts`:**
    POST endpoint. Authenticates user via `createClient()` from `@/lib/supabase/server`. Reads `{ draftId }` from request body. Verifies draft exists, belongs to user, and has status `'ready'`. Creates Stripe Checkout Session using `stripe.checkout.sessions.create()` with:
    - `mode: "payment"`
    - `customer_email: user.email`
    - `client_reference_id: draftId`
    - `metadata: { draft_id: draftId, user_id: user.id }`
    - `line_items` with inline `price_data` (unit_amount=1499, currency="usd", product_data with name and description including model count from draft.selected_models)
    - `success_url: ${NEXT_PUBLIC_SITE_URL}/checkout/success?session_id={CHECKOUT_SESSION_ID}`
    - `cancel_url: ${NEXT_PUBLIC_SITE_URL}/benchmark/new?draft=${draftId}`
    Returns JSON `{ url: session.url }`. Handles errors with appropriate status codes (401, 404, 500).

    **Create `src/app/api/webhooks/stripe/route.ts`:**
    CRITICAL: Set `export const maxDuration = 800;` at the top for Vercel Fluid Compute.
    POST endpoint. Does NOT use Supabase user client (no session in webhooks).
    1. Read raw body with `request.text()` (NOT `.json()` -- signature verification requires raw body)
    2. Get `stripe-signature` header
    3. Verify signature with `stripe.webhooks.constructEvent(body, signature, STRIPE_WEBHOOK_SECRET)`
    4. If `event.type === "checkout.session.completed"`:
       a. Extract `draft_id` and `user_id` from `session.metadata`
       b. Check idempotency: query reports table for existing `stripe_session_id === session.id`. If found, return 200 "Already processed"
       c. Load draft from benchmark_drafts by draftId
       d. Create report record with: `user_id`, `draft_id`, `stripe_session_id: session.id`, `status: "paid"`, `config_snapshot` (snapshot of draft's config_data, upload_data, schema_data, selected_models), `image_paths` (extracted from upload_data), `extraction_prompt` (from schema_data.prompt), `json_schema` (from schema_data.userSchema or inferredSchema)
       e. Update draft status to `"paid"`
       f. Use `after()` from `next/server` to trigger `runBenchmark(report.id)` in background after returning response. Import the `runBenchmark` function but note it will be created in plan 02-03 -- for now, create a placeholder function in this file that logs a message: `console.log("[benchmark] Would run benchmark for report:", reportId)`. The real implementation will be wired in plan 02-03.
    5. Return `new Response("OK", { status: 200 })`
    Handle errors: 400 for invalid signature, 400 for missing metadata, 404 for missing draft.

    **Create `src/app/checkout/success/page.tsx`:**
    Public page (outside (app) route group, no auth required). Reads `session_id` from URL search params. Shows a success message: "Payment confirmed! Your benchmark is being prepared." with a link to the processing page. Use Suspense boundary for client-side search params. Query the checkout session via a server action or API call to get the report ID from session metadata, then redirect to `/benchmark/{reportId}/processing`. If session_id is missing, show a generic success message with link to dashboard.

    **Create `src/app/checkout/cancel/page.tsx`:**
    Public page. Shows "Payment cancelled" message with a link back to the dashboard or to retry. Simple static page with Tailwind styling matching the dark-warm palette.

    **Create `src/app/(app)/benchmark/[id]/processing/page.tsx`:**
    Authenticated page (inside (app) route group). Receives report ID from URL params. Polls the report status every 3 seconds using `setInterval` + `fetch` to a query. Shows:
    - "Processing your benchmark..." with a spinner while status is 'paid' or 'running'
    - Report status text (paid -> "Starting benchmark...", running -> "Running benchmarks...")
    - When status becomes 'complete', show "Benchmark complete!" and redirect to `/report/{id}` (Phase 3 will build the actual report page, but the link should be ready)
    - When status becomes 'failed', show error message with retry option
    Create an API route or use the Supabase client directly to query report status. Using the Supabase browser client is simpler -- just query `reports` table by ID where `user_id` matches.

    **Update `src/app/(app)/benchmark/new/page.tsx`:**
    Add checkout integration to the wizard completion flow. When the user has a draft with status='ready' and clicks the "Pay & Run Benchmark" button (currently should exist from Phase 1 Step 3 completion), call `POST /api/checkout` with the draftId and redirect to the returned Stripe URL via `window.location.href = url`. Handle loading state on the button during the API call. If the checkout API returns an error, show a toast/alert.
  </action>
  <verify>
    1. `npm run build` passes
    2. `curl -X POST http://localhost:3000/api/checkout -H "Content-Type: application/json" -d '{"draftId":"test"}' 2>/dev/null | head` returns 401 (not authenticated) -- confirms route exists
    3. `grep "checkout.session.completed" src/app/api/webhooks/stripe/route.ts` confirms webhook event handling
    4. `grep "maxDuration" src/app/api/webhooks/stripe/route.ts` confirms Fluid Compute config
    5. `grep "stripe_session_id" src/app/api/webhooks/stripe/route.ts` confirms idempotency check
    6. `ls src/app/checkout/success/page.tsx src/app/checkout/cancel/page.tsx src/app/\\(app\\)/benchmark/\\[id\\]/processing/page.tsx` confirms all pages exist
  </verify>
  <done>
    Checkout API creates Stripe session and redirects user. Webhook verifies signature, checks idempotency, creates report from draft snapshot, and triggers background benchmark (placeholder). Success page redirects to processing page. Cancel page links back to wizard. Processing page polls report status. Wizard "Pay" button wired to checkout flow.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build` exits 0
2. Stripe client initializes without errors (verified by build)
3. All API routes exist and handle basic request validation
4. Database migration SQL is syntactically valid
5. TypeScript types are consistent between database.ts and migration SQL
6. Webhook handler uses `request.text()` for raw body (not `.json()`)
7. Webhook handler checks `stripe_session_id` uniqueness before creating report
8. `maxDuration = 800` is set on the webhook route
</verification>

<success_criteria>
- Stripe Checkout session can be created from a 'ready' draft
- Webhook handler verifies signature and creates report with idempotency
- Processing page exists and polls report status
- All new env vars documented in .env.local.example
- Database migration adds benchmark_runs table and stripe_session_id column
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-pay-and-run/02-01-SUMMARY.md`
</output>
